{
    "docs": [
        {
            "location": "/", 
            "text": "Granite Framework\n\n\nGranite is Business Actions architecture for Rails apps.\n\n\nIt's a combination of user interaction (attributes and validations), context (preconditions) and\npermissions (authorization policies).\n\n\nBusiness actions\n\n\nThe central concept of Granite is a business action. Each business action can\nhave a simple \nexecute_perform!\n method.\n\n\nHello world\n\n\nBasically it is an active model-like class (form object) defined to execute a sequence of commands. The simplest business action looks like this:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nprivate\n \ndef\n \nexecute_perform!\n(\n*\n)\n\n    \nputs\n \nHello World\n\n  \nend\n\n\nend\n\n\n\n\n\n\nThere are two ways of executing newly defined business action: using \n#perform\n or \n#perform!\n method:\n\n\n[1] pry(main)\n Action.new.perform!\n\n\n   (0.3ms)  BEGIN\n\n\nHello World\n\n\n   (0.1ms)  COMMIT\n\n\n=\n true\n\n\n[2] pry(main)\n Action.new.perform\n\n\n   (0.2ms)  BEGIN\n\n\nHello World\n\n\n   (0.2ms)  COMMIT\n\n\n=\n true\n\n\n\n\n\n\nAs you can see from log, every action execution is wrapped inside a DB transaction.\nThe main difference between these methods is: \n#perform!\n raises exception in case of errors and \n#perform\n simply returns \nfalse\n\n\nPerformer\n\n\nEvery BA has a performer which can be assigned via \n.as\n class method before BA creation.\n\n\nMyAction\n.\nas\n(\nAdmin\n.\nfirst\n)\n.\nnew\n(\nparams\n)\n\n\n\n\n\n\nPerformer can be any Ruby object. By default performer is \nnil\n.\n\n\nAttributes\n\n\nThe next step is defining action attributes. There are several types of them and they are provided by \nactive_data\n gem:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nattribute\n \n:name\n,\n \nString\n\n  \ncollection\n \n:ids\n,\n \nInteger\n\n\n  \nprivate\n \ndef\n \nexecute_perform!\n(\n*\n)\n\n    \nputs\n \nHello World\n\n  \nend\n\n\nend\n\n\n\n\n\n\nFor detailed information on the available types and usage examples, check out \nActiveData documentation\n.\n\n\nThe attributes behave pretty much as they do with \nActiveData\n objects, except for \nrepresents\n:\n\n\nRepresents\n\n\nIn \nActiveData\n objects, when a model attribute is exposed through \nrepresents\n and the AD object changes, the exposed attribute is updated right away, and Granite Actions update the represented attribute \nbefore_validation\n.\n\n\nAssociations\n\n\nGranite actions can also define several associations:\n\n\nclass\n \nCreateBook\n \n \nGranite\n::\nAction\n\n  \nattribute\n \n:name\n,\n \nString\n\n  \nreferences_one\n \n:author\n\n  \nembeds_many\n \n:reviews\n\n\nend\n\n\n\n\n\n\nFor more information on the associations available and usage examples, see \nActiveData documentation\n.\n\n\nNestedActions\n\n\nSome business actions call other actions as part of their own action. For cases like that we should define memoizable method that\nreturns instance of subaction.\n\n\nmemoize\n \ndef\n \nsubaction\n\n  \nMySubactionClass\n.\nnew\n\n\nend\n\n\n\n\n\n\nSubactions will validate their data and check preconditions when they're performed. This however should not be relied on\nand it's better to check preconditions of subaction when precondtions of main action are checked and validate subaction\nwhen main action is validated. For this we use:\n\n\nprecondition\n \nembedded\n:\n \n:subaction\n\n\nvalidates\n \n:subaction\n,\n \nnested\n:\n \ntrue\n\n\n\n\n\n\nSubject\n\n\nSubject definition does three things: defines \nreferences_one\n association, aliases its methods\nto common names (\nsubject\n and \nsubject_id\n) and modifies action initializer, providing ability to pass subject as the first\nargument and restricting subject-less action initialization.\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nsubject\n \n:user\n\n\n  \nprivate\n \ndef\n \nexecute_perform!\n(\n*\n);\n \nend\n\n\nend\n\n\n\n\n\n\n[1] pry(main)\n Action.new # =\n ArgumentError\n\n\n[2] pry(main)\n Action.new(User.first)\n\n\n=\n #\nAction user: #\nReferencesOne #\nUser id: 1...\n, user_id: 1\n\n\n[3] pry(main)\n Action.new(1)\n\n\n=\n #\nAction user: #\nReferencesOne #\nUser id: 1...\n, user_id: 1\n\n\n[4] pry(main)\n Action.new(user: User.first)\n\n\n=\n #\nAction user: #\nReferencesOne #\nUser id: 1...\n, user_id: 1\n\n\n[5] pry(main)\n Action.new(subject: User.first)\n\n\n=\n #\nAction user: #\nReferencesOne #\nUser id: 1...\n, user_id: 1\n\n\n[6] pry(main)\n Action.new(user_id: 1)\n\n\n=\n #\nAction user: #\nReferencesOne #\nUser id: 1...\n, user_id: 1\n\n\n[7] pry(main)\n Action.new(id: 1)\n\n\n=\n #\nAction user: #\nReferencesOne #\nUser id: 1...\n, user_id: 1\n\n\n\n\n\n\nAs you can see \n#user\n is aliased to \n#subject\n and \n#user_id\n is aliased to \n#id\n. Also subject call takes any combination of \nreferences_one\n possible options.\n\n\nPolicies, preconditions, validations\n\n\nThe main question is how to choose suitable construction. Here are simple rules:\n\n\n\n\nIf condition is dependent on any of user provided attribute values except subject - it is a validation.\n\n\nIf condition depends on subject or any value found depending on subject - it is a precondition.\n\n\nOtherwise if it is related to performer - it is a policy.\n\n\n\n\nPolicies\n\n\nPerforming restrictions for the performer:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nallow_if\n \n{\n \nperformer\n.\npresent?\n \n}\n\n  \nallow_self\n \n# equal to allow_if { performer == subject }\n\n\nend\n\n\n\n\n\n\nPolicies support strategies. If default \nAnyStrategy\n doesn't fit your needs\nyou can use \nAlwaysAllowStrategy\n, \nRequiredPerformerStrategy\n\nor write your own. You can use new strategy like that:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nself\n.\n_policies_strategy\n \n=\n \nMyCustomStrategy\n\n\nend\n\n\n\n\n\n\nPreconditions\n\n\nThis is a subject-related prevalidation, working in the same way as validations with blocks,\nbut \ndecline_with\n method is used instead of \nerrors.add\n:\n\n\nprecondition\n \ndo\n\n  \ndecline_with\n(\n:inactive\n)\n \nunless\n \nsubject\n.\nactive?\n\n\nend\n\n\n\n\n\n\nIn case you have subactions which you perform inside your action you can\ncheck subaction preconditions by simple embedding:\n\n\nprecondition\n \nembedded\n:\n \n:my_custom_action\n\n\n\n\n\n\nYou can specify conditions when precondition block should be executed with \n:if\n (and only \n:if\n) statement.\n\n\nprecondition\n \nif\n:\n \n-\n \n{\n \nsubject\n.\nactive?\n \n}\n \ndo\n\n  \ndecline_with\n(\n:too_young\n)\n \nif\n \nsubject\n.\nage\n \n \n30\n\n\nend\n\n\n\n\n\n\nValidations\n\n\nYou are able to use any of ActiveModel-provided validations.\n\n\nContext validations\n\n\nContext validations (\nsee the note about the \ncontext\n argument\n) are supported and embraced by Granite. You can specify the \non:\n key with any validation to declare a context in which the validation should be executed. Such validations will be triggered only when the provided context was specified explicitly.\n\n\nTo specify a context with the built-in ActiveModel methods \nvalid?\n and \ninvalid?\n, simply provide the context as the first argument.\n\n\nTo specify a context with \nperform\n, \nperform!\n, or \ntry_perform!\n, pass the name of the context as a keyword argument \ncontext:\n.\n\n\nYou should use context validations when a single action could be triggered in different scenarios (e.g. by a staff member and a user) and different validation behavior is required.\n\n\nConsider this simplified business action for updating a portfolio of a user:\n\n\nclass\n \nBA\n::\nUser\n::\nUpdatePortfolio\n \n \nGranite\n::\nAction\n\n  \nsubject\n \n:user\n\n\n  \nrepresents\n \n:full_name\n,\n \nof\n:\n \n:subject\n\n\n  \nvalidates\n \n:full_name\n,\n \npresence\n:\n \ntrue\n,\n \non\n:\n \n:user\n\n\n  \nprivate\n \ndef\n \nexecute_perform!\n(\n*\n)\n\n    \n# ...\n\n  \nend\n\n\nend\n\n\n\n\n\n\nTo run a business action without context you can simply send the \nperform!\n message to the action. It won't require full_name to be present.\nIf you want a validation to be executed in this scope you can add context argument to perform call: \nperform!(context: :user)\n.\n\n\nExceptions handling\n\n\nGranite has built-in mechanism for exceptions handling (similar to \nrescue_from\n known from \nActionController\n). You are able to register handlers for any exception type, like this:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nhandle_exception\n \nThirdPartyLib\n::\nAPIError\n \ndo\n \n|\nerror\n|\n\n    \ndecline_with\n(\n:third_party_lib_failed\n)\n\n  \nend\n\n\n  \nprivate\n \ndef\n \nexecute_perform!\n(\n*\n)\n\n    \nThirdPartyLib\n.\napi_call\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAdding errors to action object is important, because each time handled exception is raised,\n\nGranite::Action::ValidationError\n is raised.\nValidation exception will have the same backtrace as original error.\nPrefer this way over custom exception handling in private methods.\n\n\nI18n\n\n\nThere are special I18n rules working in action. If I18n identifier is prefixed with \n.\n (\nt('.foobar')\n) - then translations lookup happens in following order:\n\n\ngranite_action.#{granite_action_name}.foobar\ngranite_action.granite/action.foobar\nfoobar\n\n\n\n\n\nNote that rules are different for \nI18n lookup inside a projector context\n.\n\n\nGenerator\n\n\nYou can use granite generator to generate a starting point for your action. You have to pass name and path of action as first argument. Basic usage is:\n\nrails g granite SUBJECT/ACTION [PROJECTOR]\n.\nYou can use \n-C\n or \n--collection\n option to generate collection action where subject is not known when initializing action.\nYou can pass a second argument to generator to specify projector name.\n\n\nrails g granite user/create\n\n\n  create  apq/actions/ba/user/create.rb\n  create  apq/actions/ba/user/business_action.rb\n  create  spec/apq/actions/ba/user/create_spec.rb\n\n\n\n\n\nrails g granite user/create -C\n\n\n  create  apq/actions/ba/user/create.rb\n  create  spec/apq/actions/ba/user/create_spec.rb\n\n\n\n\n\nrails g granite user/create simple\n\n\n  create  apq/actions/ba/user/create/simple\n  create  apq/actions/ba/user/create.rb\n  create  apq/actions/ba/user/business_action.rb\n  create  spec/apq/actions/ba/user/create_spec.rb", 
            "title": "Home"
        }, 
        {
            "location": "/#granite-framework", 
            "text": "Granite is Business Actions architecture for Rails apps.  It's a combination of user interaction (attributes and validations), context (preconditions) and\npermissions (authorization policies).", 
            "title": "Granite Framework"
        }, 
        {
            "location": "/#business-actions", 
            "text": "The central concept of Granite is a business action. Each business action can\nhave a simple  execute_perform!  method.", 
            "title": "Business actions"
        }, 
        {
            "location": "/#hello-world", 
            "text": "Basically it is an active model-like class (form object) defined to execute a sequence of commands. The simplest business action looks like this:  class   Action     Granite :: Action \n   private   def   execute_perform! ( * ) \n     puts   Hello World \n   end  end   There are two ways of executing newly defined business action: using  #perform  or  #perform!  method:  [1] pry(main)  Action.new.perform!     (0.3ms)  BEGIN  Hello World     (0.1ms)  COMMIT  =  true  [2] pry(main)  Action.new.perform     (0.2ms)  BEGIN  Hello World     (0.2ms)  COMMIT  =  true   As you can see from log, every action execution is wrapped inside a DB transaction.\nThe main difference between these methods is:  #perform!  raises exception in case of errors and  #perform  simply returns  false", 
            "title": "Hello world"
        }, 
        {
            "location": "/#performer", 
            "text": "Every BA has a performer which can be assigned via  .as  class method before BA creation.  MyAction . as ( Admin . first ) . new ( params )   Performer can be any Ruby object. By default performer is  nil .", 
            "title": "Performer"
        }, 
        {
            "location": "/#attributes", 
            "text": "The next step is defining action attributes. There are several types of them and they are provided by  active_data  gem:  class   Action     Granite :: Action \n   attribute   :name ,   String \n   collection   :ids ,   Integer \n\n   private   def   execute_perform! ( * ) \n     puts   Hello World \n   end  end   For detailed information on the available types and usage examples, check out  ActiveData documentation .  The attributes behave pretty much as they do with  ActiveData  objects, except for  represents :", 
            "title": "Attributes"
        }, 
        {
            "location": "/#represents", 
            "text": "In  ActiveData  objects, when a model attribute is exposed through  represents  and the AD object changes, the exposed attribute is updated right away, and Granite Actions update the represented attribute  before_validation .", 
            "title": "Represents"
        }, 
        {
            "location": "/#associations", 
            "text": "Granite actions can also define several associations:  class   CreateBook     Granite :: Action \n   attribute   :name ,   String \n   references_one   :author \n   embeds_many   :reviews  end   For more information on the associations available and usage examples, see  ActiveData documentation .", 
            "title": "Associations"
        }, 
        {
            "location": "/#nestedactions", 
            "text": "Some business actions call other actions as part of their own action. For cases like that we should define memoizable method that\nreturns instance of subaction.  memoize   def   subaction \n   MySubactionClass . new  end   Subactions will validate their data and check preconditions when they're performed. This however should not be relied on\nand it's better to check preconditions of subaction when precondtions of main action are checked and validate subaction\nwhen main action is validated. For this we use:  precondition   embedded :   :subaction  validates   :subaction ,   nested :   true", 
            "title": "NestedActions"
        }, 
        {
            "location": "/#subject", 
            "text": "Subject definition does three things: defines  references_one  association, aliases its methods\nto common names ( subject  and  subject_id ) and modifies action initializer, providing ability to pass subject as the first\nargument and restricting subject-less action initialization.  class   Action     Granite :: Action \n   subject   :user \n\n   private   def   execute_perform! ( * );   end  end   [1] pry(main)  Action.new # =  ArgumentError  [2] pry(main)  Action.new(User.first)  =  # Action user: # ReferencesOne # User id: 1... , user_id: 1  [3] pry(main)  Action.new(1)  =  # Action user: # ReferencesOne # User id: 1... , user_id: 1  [4] pry(main)  Action.new(user: User.first)  =  # Action user: # ReferencesOne # User id: 1... , user_id: 1  [5] pry(main)  Action.new(subject: User.first)  =  # Action user: # ReferencesOne # User id: 1... , user_id: 1  [6] pry(main)  Action.new(user_id: 1)  =  # Action user: # ReferencesOne # User id: 1... , user_id: 1  [7] pry(main)  Action.new(id: 1)  =  # Action user: # ReferencesOne # User id: 1... , user_id: 1   As you can see  #user  is aliased to  #subject  and  #user_id  is aliased to  #id . Also subject call takes any combination of  references_one  possible options.", 
            "title": "Subject"
        }, 
        {
            "location": "/#policies-preconditions-validations", 
            "text": "The main question is how to choose suitable construction. Here are simple rules:   If condition is dependent on any of user provided attribute values except subject - it is a validation.  If condition depends on subject or any value found depending on subject - it is a precondition.  Otherwise if it is related to performer - it is a policy.", 
            "title": "Policies, preconditions, validations"
        }, 
        {
            "location": "/#policies", 
            "text": "Performing restrictions for the performer:  class   Action     Granite :: Action \n   allow_if   {   performer . present?   } \n   allow_self   # equal to allow_if { performer == subject }  end   Policies support strategies. If default  AnyStrategy  doesn't fit your needs\nyou can use  AlwaysAllowStrategy ,  RequiredPerformerStrategy \nor write your own. You can use new strategy like that:  class   Action     Granite :: Action \n   self . _policies_strategy   =   MyCustomStrategy  end", 
            "title": "Policies"
        }, 
        {
            "location": "/#preconditions", 
            "text": "This is a subject-related prevalidation, working in the same way as validations with blocks,\nbut  decline_with  method is used instead of  errors.add :  precondition   do \n   decline_with ( :inactive )   unless   subject . active?  end   In case you have subactions which you perform inside your action you can\ncheck subaction preconditions by simple embedding:  precondition   embedded :   :my_custom_action   You can specify conditions when precondition block should be executed with  :if  (and only  :if ) statement.  precondition   if :   -   {   subject . active?   }   do \n   decline_with ( :too_young )   if   subject . age     30  end", 
            "title": "Preconditions"
        }, 
        {
            "location": "/#validations", 
            "text": "You are able to use any of ActiveModel-provided validations.", 
            "title": "Validations"
        }, 
        {
            "location": "/#context-validations", 
            "text": "Context validations ( see the note about the  context  argument ) are supported and embraced by Granite. You can specify the  on:  key with any validation to declare a context in which the validation should be executed. Such validations will be triggered only when the provided context was specified explicitly.  To specify a context with the built-in ActiveModel methods  valid?  and  invalid? , simply provide the context as the first argument.  To specify a context with  perform ,  perform! , or  try_perform! , pass the name of the context as a keyword argument  context: .  You should use context validations when a single action could be triggered in different scenarios (e.g. by a staff member and a user) and different validation behavior is required.  Consider this simplified business action for updating a portfolio of a user:  class   BA :: User :: UpdatePortfolio     Granite :: Action \n   subject   :user \n\n   represents   :full_name ,   of :   :subject \n\n   validates   :full_name ,   presence :   true ,   on :   :user \n\n   private   def   execute_perform! ( * ) \n     # ... \n   end  end   To run a business action without context you can simply send the  perform!  message to the action. It won't require full_name to be present.\nIf you want a validation to be executed in this scope you can add context argument to perform call:  perform!(context: :user) .", 
            "title": "Context validations"
        }, 
        {
            "location": "/#exceptions-handling", 
            "text": "Granite has built-in mechanism for exceptions handling (similar to  rescue_from  known from  ActionController ). You are able to register handlers for any exception type, like this:  class   Action     Granite :: Action \n   handle_exception   ThirdPartyLib :: APIError   do   | error | \n     decline_with ( :third_party_lib_failed ) \n   end \n\n   private   def   execute_perform! ( * ) \n     ThirdPartyLib . api_call \n   end  end   Adding errors to action object is important, because each time handled exception is raised, Granite::Action::ValidationError  is raised.\nValidation exception will have the same backtrace as original error.\nPrefer this way over custom exception handling in private methods.", 
            "title": "Exceptions handling"
        }, 
        {
            "location": "/#i18n", 
            "text": "There are special I18n rules working in action. If I18n identifier is prefixed with  .  ( t('.foobar') ) - then translations lookup happens in following order:  granite_action.#{granite_action_name}.foobar\ngranite_action.granite/action.foobar\nfoobar  Note that rules are different for  I18n lookup inside a projector context .", 
            "title": "I18n"
        }, 
        {
            "location": "/#generator", 
            "text": "You can use granite generator to generate a starting point for your action. You have to pass name and path of action as first argument. Basic usage is: rails g granite SUBJECT/ACTION [PROJECTOR] .\nYou can use  -C  or  --collection  option to generate collection action where subject is not known when initializing action.\nYou can pass a second argument to generator to specify projector name.  rails g granite user/create    create  apq/actions/ba/user/create.rb\n  create  apq/actions/ba/user/business_action.rb\n  create  spec/apq/actions/ba/user/create_spec.rb  rails g granite user/create -C    create  apq/actions/ba/user/create.rb\n  create  spec/apq/actions/ba/user/create_spec.rb  rails g granite user/create simple    create  apq/actions/ba/user/create/simple\n  create  apq/actions/ba/user/create.rb\n  create  apq/actions/ba/user/business_action.rb\n  create  spec/apq/actions/ba/user/create_spec.rb", 
            "title": "Generator"
        }, 
        {
            "location": "/projectors/", 
            "text": "Projectors\n\n\nIf you only want an abstraction for complex logic in your existing controller, you can just instantiate the Granite Action in the controller action:\n\n\nclass\n \nMoviesController\n \n \nApplicationController\n\n  \n# ...\n\n  \n# Regular controller definition\n\n  \n# ...\n\n  \ndef\n \ncreate\n\n    \nBA\n::\nMovies\n::\nCreate\n.\nas\n(\ncurrent_user\n)\n.\nnew\n(\nsome_params\n)\n.\nperform!\n\n  \nend\n\n  \n# ...\n\n\nend\n\n\n\n\n\n\nHowever, this boilerplate code can quickly become rather repetitive, therefore it's recommended to use projectors.\n\n\nThe main purpose of projectors is to DRY copy-pasted controller actions and decorator methods. Projectors are the way to enable self-rendering of business actions into user interface.\n\n\nBasics\n\n\nA projector file consists of two parts: a controller part and a decorator part. The decorator part is actually the projector class itself and the controller class is a nested class defined implicitly and accessible via \nTestProjector.controller_class\n.\n\n\nclass\n \nTestProjector\n \n \nGranite\n::\nProjector\n\n\nend\n\n\n\n\n\n\nProjectors must be mounted into actions and routes. It is possible to mount several projectors onto one action (for example we have to be able to execute a business action via a standard confirmation dialog or using inline editing) and also to have one projector mounted by several actions:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nprojector\n \n:test\n\n  \n# Or even name it as necessary:\n\n  \n# projector :main, class_name: \nTestProjector\n\n\nend\n\n\n\n\n\n\nWhen a projector is mounted onto the action, an inherited projector and a controller classes are created:\n\n\n[1] pry(main)\n Action.test\n\n\n=\n Action::TestProjector\n\n\n[2] pry(main)\n Action.test.controller_class\n\n\n=\n Action::TestController\n\n\n[3] pry(main)\n Action.test.action_class\n\n\n=\n Action(no attributes)\n\n\n[4] pry(main)\n Action.test.controller_class.action_class\n\n\n=\n Action(no attributes)\n\n\n\n\n\n\nProjectors are mounted onto routes by specifying a path to the projector as a string.\n If a business action has multiple projectors, all of them have to be mounted separately in routes.\n If an action does not have a subject, it should be mounted explicitly inside the \ncollection\n block:\n\n\nWhen \ngranite\n is called in routes - simply every controller of every projector mounted to the specified action is taken and its controller actions are mounted onto the routes. It is possible to mount particular projectors as well.\n\n\nProjectors can only be mounted inside of resource and are mounted on \n:member\n if they have \nsubject\n and on \n:collection\n if they don't:\n\n\nApplication\n.\nroutes\n.\ndraw\n \ndo\n\n  \nresources\n \n:users\n,\n \nonly\n:\n \n[\n:index\n]\n \ndo\n\n    \ncollection\n \ndo\n\n      \ngranite\n \ncreate#my_projector\n\n    \nend\n\n\n    \ngranite\n \nremove#my_projector\n\n  \nend\n\n\nend\n\n\n\n\n\n\nWhen you mount a projector, the route will be defined by the resources block you're in and the string provided.\nThe Granite action and projector will be infered by the parameter, split by the \n#\n character.\nIn the previous example, route would be \n/users/create/:projector_action\n, action would be \nCreate\n and projector \nMyProjector\n.\n\n:projector_action\n refers to the projector controller action. For instance:\n\n\nclass\n \nFooProjector\n \n \nGranite\n::\nProjector\n\n  \nget\n \n:baz\n,\n \nas\n:\n \n \ndo\n\n    \n# ...\n\n  \nend\n\n\n  \nget\n \n:bar\n \ndo\n\n    \nrender\n \njson\n:\n \n{\n \ncats\n:\n \nnice\n \n}\n\n  \nend\n\n\nend\n\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nprojector\n \n:foo\n\n\nend\n\n\n\n# config/routes.rb\n\n\n# ...\n\n\nresources\n \n:bunnies\n \ndo\n\n  \ngranite\n \naction#foo\n\n\nend\n\n\n\n\n\n\nIn this case, the route '/bunnies/action/bar' would lead to \nFooProjector#bar\n action, and '/bunnies/action' would go to \nFooProjector#baz\n.\n\n\nNormally projectors are mounted under \n/:action/:projector_action\n where \n:action\n is name of the BA and\n\n:projector_action\n is mapped to projector controller action.\n\n\nNote that if you have multiple projectors on the same action they might be using same routes. To prevent any clashes\nbetween projectors it is recommended to mount the second projector with \nprojector_prefix: true\n, which will mount this\nprojector under \n/:projector_:action/:projector_action\n instead of \n/:action/:projector_action\n. Same goes for path\nhelper method, it will be \nprojector_action_subject_path\n instead of \naction_subject_path\n.\n\n\nYou can also customize mount path using \npath: '/my_custom_path', as: :my_custom_action\n.\n\n\nIt's also possible to restrict action HTTP verbs using \nvia: :post\n (or \n:get\n, or any valid HTTP action).\n\n\nIt is possible to access projector instance from action instance by projector name as well:\n\n\n[1] pry(main)\n Action.new.test\n\n\n=\n #\nAction::TestProjector:0x007f98bde9ac98 @action=#\nAction (no attributes)\n\n\n[2] pry(main)\n Action.new.test.action\n\n\n=\n #\nAction (no attributes)\n\n\n\n\n\n\nI18n projectors lookup\n\n\nAs in granite actions, there are special I18n rules working in projectors.\nIf I18n identifier is prefixed with \n.\n (\nt('.foobar')\n) - then translations lookup happens in following order:\n\n\ngranite_action.ba/#{granite_action_name}.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.ba/#{granite_action_name}.#{granite_projector_name}.foobar\ngranite_action.base_action.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.base_action.#{granite_projector_name}.foobar\ngranite_action.granite/action.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.granite/action.#{granite_projector_name}.foobar\n#{granite_projector_name}.#{view_name}.foobar\n#{granite_projector_name}.foobar\n\n\n\n\n\nDecorator part\n\n\nSince projector acts exactly like decorator does, it is possible to define helpers on projector instance level:\n\n\nclass\n \nTestProjector\n \n \nGranite\n::\nProjector\n\n  \ndef\n \nlink\n\n    \nh\n.\nlink_to\n \naction\n.\nsubject\n.\nfull_name\n,\n \naction\n.\nsubject\n\n  \nend\n\n\nend\n\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nprojector\n \n:test\n\n  \nsubject\n \n:user\n\n\nend\n\n\n\n\n\n\nInside the application it would be possible to call it like this:\n\n\nAction\n.\nnew\n(\nUser\n.\nfirst\n)\n.\ntest\n.\nlink\n\n\n# =\n \na href=\\\n/user/112014\\\nSebasti\u00e1n L\u00f3pez Alfonso\n/a\n\n\n\n\n\n\nController part\n\n\nThe main purpose of a controller is to serve actions, but since we have to detect controller actions automatically in order to dispatch requests to them, we need a small DSL here:\n\n\nclass\n \nTestProjector\n \n \nGranite\n::\nProjector\n\n  \nget\n \n:help\n \ndo\n\n    \n# render a view that shows help\n\n  \nend\n\n\n  \nget\n \n:form\n,\n \nas\n:\n \n \ndo\n\n    \n# render a form. This is a default `get` action for this controller\n\n  \nend\n\n\n  \npost\n \n:perform\n,\n \nas\n:\n \n \ndo\n\n    \n# process the form. This is a default `post` action for this controller\n\n  \nend\n\n\nend\n\n\n\n\n\n\nThe first thing here is a verb definition: it is possible to use any REST verb. The second thing is a mount point name to make routes look beautiful. It is provided with the \n:as\n option. You'll probably want to set it to empty string so that the actual controller action is not part of the URL, since the name of the business action is.\n\n\nFor instance, if we mounted the \nBA::Company::Create\n business action that had a projector with \nperform\n controller action, the path to the action by default would have been \ncreate/perform\n. By adding \nas: ''\n to the \nperform\n action definition we change the path to \ncreate\n.\n\n\nPlease keep in mind that provided code defines methods called \nhelp\n, \nform\n, and \nperform\n in the \ncontroller_class\n.\n\n\nNote that calling \nrender\n inside those blocks does not render the view within the application layout implicitly. To do so, you need to pass \nlayout: 'application'\n to the \nrender\n call.\n\n\nCustomizations\n\n\nThe controller is inherited from \nGranite::Controller\n which by default inherits from \nActionController::Base\n this can be customized with initializer:\n\n\nGranite\n.\ntap\n \ndo\n \n|\nm\n|\n\n  \nm\n.\nbase_controller\n \n=\n \nApplicationController\n\n\nend\n\n\n\n\n\n\nTo set performer for granite actions implement \nprojector_performer\n, for example:\n\n\nalias\n \nprojector_performer\n \ncurrent_user\n\n\n\n\n\n\nGranite::Controller\n can be customized further after \nrails generate granite:install_controller\n, the original controller will be installed in \napp/controllers/granite/controller.rb\n.\n\n\nHandling policies not allowed\n\n\nWhen action policies are not satisfied action will raise an exception \nGranite::Action::NotAllowedError\n, it should be handled in the \nbase_controller_class\n:\n\n\n  \nrescue_from\n \nGranite\n::\nAction\n::\nNotAllowedError\n \ndo\n \n|\nexception\n|\n\n    \n...\n\n  \nend\n\n\n\n\n\n\nProjectors extension\n\n\nSince we are creating projector subclasses when mounting to business actions \u2014 there should be an ability to extend and modify them. This can be easily achieved by passing a block to the projector mount declaration:\n\n\nclass\n \nAction\n \n \nGranite\n::\nAction\n\n  \nprojector\n \n:test\n \ndo\n\n    \ncontroller_class\n.\nbefore_action\n \n{\n \n...\n \n}\n\n\n    \ndef\n \nlink_class\n\n      \nsuper-link\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nThis is useful for providing exact projector configuration or even controller extensions. In the most cases it would be preferable to derive a new projector from a standard one.\n\n\nViews\n\n\nViews are used the same way as for usual controllers, but stored and inherited in slightly different way: basic views are stored in \napq/projectors/#{projector_name}\n directory.\n\n\nIf you need to redefine any template in particular action - just put it near the action: e.g. \napq/actions/ba/#{action_name}/#{projector_name}\n for \nBA::ActionName.projector_name\n projector", 
            "title": "Projectors"
        }, 
        {
            "location": "/projectors/#projectors", 
            "text": "If you only want an abstraction for complex logic in your existing controller, you can just instantiate the Granite Action in the controller action:  class   MoviesController     ApplicationController \n   # ... \n   # Regular controller definition \n   # ... \n   def   create \n     BA :: Movies :: Create . as ( current_user ) . new ( some_params ) . perform! \n   end \n   # ...  end   However, this boilerplate code can quickly become rather repetitive, therefore it's recommended to use projectors.  The main purpose of projectors is to DRY copy-pasted controller actions and decorator methods. Projectors are the way to enable self-rendering of business actions into user interface.", 
            "title": "Projectors"
        }, 
        {
            "location": "/projectors/#basics", 
            "text": "A projector file consists of two parts: a controller part and a decorator part. The decorator part is actually the projector class itself and the controller class is a nested class defined implicitly and accessible via  TestProjector.controller_class .  class   TestProjector     Granite :: Projector  end   Projectors must be mounted into actions and routes. It is possible to mount several projectors onto one action (for example we have to be able to execute a business action via a standard confirmation dialog or using inline editing) and also to have one projector mounted by several actions:  class   Action     Granite :: Action \n   projector   :test \n   # Or even name it as necessary: \n   # projector :main, class_name:  TestProjector  end   When a projector is mounted onto the action, an inherited projector and a controller classes are created:  [1] pry(main)  Action.test  =  Action::TestProjector  [2] pry(main)  Action.test.controller_class  =  Action::TestController  [3] pry(main)  Action.test.action_class  =  Action(no attributes)  [4] pry(main)  Action.test.controller_class.action_class  =  Action(no attributes)   Projectors are mounted onto routes by specifying a path to the projector as a string.\n If a business action has multiple projectors, all of them have to be mounted separately in routes.\n If an action does not have a subject, it should be mounted explicitly inside the  collection  block:  When  granite  is called in routes - simply every controller of every projector mounted to the specified action is taken and its controller actions are mounted onto the routes. It is possible to mount particular projectors as well.  Projectors can only be mounted inside of resource and are mounted on  :member  if they have  subject  and on  :collection  if they don't:  Application . routes . draw   do \n   resources   :users ,   only :   [ :index ]   do \n     collection   do \n       granite   create#my_projector \n     end \n\n     granite   remove#my_projector \n   end  end   When you mount a projector, the route will be defined by the resources block you're in and the string provided.\nThe Granite action and projector will be infered by the parameter, split by the  #  character.\nIn the previous example, route would be  /users/create/:projector_action , action would be  Create  and projector  MyProjector . :projector_action  refers to the projector controller action. For instance:  class   FooProjector     Granite :: Projector \n   get   :baz ,   as :     do \n     # ... \n   end \n\n   get   :bar   do \n     render   json :   {   cats :   nice   } \n   end  end  class   Action     Granite :: Action \n   projector   :foo  end  # config/routes.rb  # ...  resources   :bunnies   do \n   granite   action#foo  end   In this case, the route '/bunnies/action/bar' would lead to  FooProjector#bar  action, and '/bunnies/action' would go to  FooProjector#baz .  Normally projectors are mounted under  /:action/:projector_action  where  :action  is name of the BA and :projector_action  is mapped to projector controller action.  Note that if you have multiple projectors on the same action they might be using same routes. To prevent any clashes\nbetween projectors it is recommended to mount the second projector with  projector_prefix: true , which will mount this\nprojector under  /:projector_:action/:projector_action  instead of  /:action/:projector_action . Same goes for path\nhelper method, it will be  projector_action_subject_path  instead of  action_subject_path .  You can also customize mount path using  path: '/my_custom_path', as: :my_custom_action .  It's also possible to restrict action HTTP verbs using  via: :post  (or  :get , or any valid HTTP action).  It is possible to access projector instance from action instance by projector name as well:  [1] pry(main)  Action.new.test  =  # Action::TestProjector:0x007f98bde9ac98 @action=# Action (no attributes)  [2] pry(main)  Action.new.test.action  =  # Action (no attributes)", 
            "title": "Basics"
        }, 
        {
            "location": "/projectors/#i18n-projectors-lookup", 
            "text": "As in granite actions, there are special I18n rules working in projectors.\nIf I18n identifier is prefixed with  .  ( t('.foobar') ) - then translations lookup happens in following order:  granite_action.ba/#{granite_action_name}.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.ba/#{granite_action_name}.#{granite_projector_name}.foobar\ngranite_action.base_action.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.base_action.#{granite_projector_name}.foobar\ngranite_action.granite/action.#{granite_projector_name}.#{view_name}.foobar\ngranite_action.granite/action.#{granite_projector_name}.foobar\n#{granite_projector_name}.#{view_name}.foobar\n#{granite_projector_name}.foobar", 
            "title": "I18n projectors lookup"
        }, 
        {
            "location": "/projectors/#decorator-part", 
            "text": "Since projector acts exactly like decorator does, it is possible to define helpers on projector instance level:  class   TestProjector     Granite :: Projector \n   def   link \n     h . link_to   action . subject . full_name ,   action . subject \n   end  end  class   Action     Granite :: Action \n   projector   :test \n   subject   :user  end   Inside the application it would be possible to call it like this:  Action . new ( User . first ) . test . link  # =   a href=\\ /user/112014\\ Sebasti\u00e1n L\u00f3pez Alfonso /a", 
            "title": "Decorator part"
        }, 
        {
            "location": "/projectors/#controller-part", 
            "text": "The main purpose of a controller is to serve actions, but since we have to detect controller actions automatically in order to dispatch requests to them, we need a small DSL here:  class   TestProjector     Granite :: Projector \n   get   :help   do \n     # render a view that shows help \n   end \n\n   get   :form ,   as :     do \n     # render a form. This is a default `get` action for this controller \n   end \n\n   post   :perform ,   as :     do \n     # process the form. This is a default `post` action for this controller \n   end  end   The first thing here is a verb definition: it is possible to use any REST verb. The second thing is a mount point name to make routes look beautiful. It is provided with the  :as  option. You'll probably want to set it to empty string so that the actual controller action is not part of the URL, since the name of the business action is.  For instance, if we mounted the  BA::Company::Create  business action that had a projector with  perform  controller action, the path to the action by default would have been  create/perform . By adding  as: ''  to the  perform  action definition we change the path to  create .  Please keep in mind that provided code defines methods called  help ,  form , and  perform  in the  controller_class .  Note that calling  render  inside those blocks does not render the view within the application layout implicitly. To do so, you need to pass  layout: 'application'  to the  render  call.", 
            "title": "Controller part"
        }, 
        {
            "location": "/projectors/#customizations", 
            "text": "The controller is inherited from  Granite::Controller  which by default inherits from  ActionController::Base  this can be customized with initializer:  Granite . tap   do   | m | \n   m . base_controller   =   ApplicationController  end   To set performer for granite actions implement  projector_performer , for example:  alias   projector_performer   current_user   Granite::Controller  can be customized further after  rails generate granite:install_controller , the original controller will be installed in  app/controllers/granite/controller.rb .", 
            "title": "Customizations"
        }, 
        {
            "location": "/projectors/#handling-policies-not-allowed", 
            "text": "When action policies are not satisfied action will raise an exception  Granite::Action::NotAllowedError , it should be handled in the  base_controller_class :     rescue_from   Granite :: Action :: NotAllowedError   do   | exception | \n     ... \n   end", 
            "title": "Handling policies not allowed"
        }, 
        {
            "location": "/projectors/#projectors-extension", 
            "text": "Since we are creating projector subclasses when mounting to business actions \u2014 there should be an ability to extend and modify them. This can be easily achieved by passing a block to the projector mount declaration:  class   Action     Granite :: Action \n   projector   :test   do \n     controller_class . before_action   {   ...   } \n\n     def   link_class \n       super-link \n     end \n   end  end   This is useful for providing exact projector configuration or even controller extensions. In the most cases it would be preferable to derive a new projector from a standard one.", 
            "title": "Projectors extension"
        }, 
        {
            "location": "/projectors/#views", 
            "text": "Views are used the same way as for usual controllers, but stored and inherited in slightly different way: basic views are stored in  apq/projectors/#{projector_name}  directory.  If you need to redefine any template in particular action - just put it near the action: e.g.  apq/actions/ba/#{action_name}/#{projector_name}  for  BA::ActionName.projector_name  projector", 
            "title": "Views"
        }, 
        {
            "location": "/testing/", 
            "text": "Testing\n\n\nGranite has multiple helpers for your rspec tests. Add \nrequire 'granite/rspec'\n to your \nrails_helper.rb\n in order\nto use them.\nAll specs that live in \nspec/apq/actions/\n will get tagged with \n:granite_action\n type and will have access to granite\naction specific helpers.\nAll specs that live in \nspec/apq/projectors/\n will get tagged with \n:granite_projector\n type and will have access to\ngranite projector specific helpers.\n\n\nSubject\n\n\n\nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nuser\n,\n \nattributes\n)\n \n}\n\n\nlet\n(\n:user\n)\n \n{\n \nUser\n.\nnew\n \n}\n\n\nlet\n(\n:attributes\n)\n \n{\n \n{}\n \n}\n\n\n\n\n\n\nProjectors\n\n\n\nit\n \n{\n \nis_expected\n.\nto\n \nhave_projector\n(\n:simple\n)\n \n}\n\n\n\n\n\n\nTest overridden projector methods:\n\n\ndescribe\n \nprojectors\n,\n \ntype\n:\n \n:granite_projector\n \ndo\n\n  \nsubject\n \n{\n \naction\n.\nmodal\n \n}\n\n  \nprojector\n \n{\n \ndescribed_class\n.\nmodal\n \n}\n\n\n  \nits\n(\n:perform_success_response\n)\n \n{\n \nis_expected\n.\nto\n \neq\n(\nmy_success\n:\n \nyes\n)\n \n}\n\n\nend\n\n\n\n\n\n\nPolicies\n\n\n\nsubject\n \n{\n \ndescribed_class\n.\nas\n(\nUser\n.\nnew\n)\n.\nnew\n \n}\n\n\nit\n \n{\n \nis_expected\n.\nto\n \nbe_allowed\n \n}\n\n\n\n\n\n\nPreconditions\n\n\n\ncontext\n \ncorrect initial state\n \ndo\n\n  \nit\n \n{\n \nis_expected\n.\nto\n \nsatisfy_preconditions\n \n}\n\n\nend\n\n\n\ncontext\n \nincorrect initial state\n \ndo\n\n  \nlet\n(\n:company\n)\n \n{\n \nbuild_stubbed\n(\n:company\n,\n \n:active\n)\n \n}\n\n  \nit\n \n{\n \nis_expected\n.\nnot_to\n \nsatisfy_preconditions\n.\nwith_message\n(\nSome validation message\n)}\n\n  \nit\n \n{\n \nis_expected\n.\nnot_to\n \nsatisfy_preconditions\n.\nwith_messages\n(\n[\nFirst validation message\n,\n \nSecond validation message\n]\n)}\n\n\nend\n\n\n\n\n\n\nValidations\n\n\n\nValidations tests are no different to ActiveRecord models tests\n\n\nPerform\n\n\n\nRun the action using \nperform!\n to test side-effects:\n\n\nspecify\n \n{\n \nexpect\n \n{\n \nperform!\n \n}\n.\nto\n \nchange\n(\nUser\n,\n \n:count\n)\n.\nby\n(\n1\n)\n \n}", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#testing", 
            "text": "Granite has multiple helpers for your rspec tests. Add  require 'granite/rspec'  to your  rails_helper.rb  in order\nto use them.\nAll specs that live in  spec/apq/actions/  will get tagged with  :granite_action  type and will have access to granite\naction specific helpers.\nAll specs that live in  spec/apq/projectors/  will get tagged with  :granite_projector  type and will have access to\ngranite projector specific helpers.", 
            "title": "Testing"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Application example\n\n\nThe business we're going to cover is very simple.\n\n\nWe have a simple book library and we need to allow logged users to create new\nbooks and rent it.\n\n\nBook library\n\n\nA symple system to track books. Each book has a title.\n\n\n\n\nThe books view is public\n\n\nOnly\n logged users can edit the books\n\n\nLogged users can \nedit\n or \nremove\n a book\n\n\n\n\nThe Rental system\n\n\n\n\nAll available books can be \nrented\n\n\nLogged users can rent a book\n\n\nA book is not \navailable\n when it's rented to someone\n\n\nA book is \navailable\n after it's delivered back\n\n\n\n\nBooks wishlist\n\n\nThe logged user can manage a \nwishlist\n considering:\n\n\n\n\nWhen a book is \nnot available\n and the user \"\ndidn't read\n it\n\n\nIf the person \nalready read\n the book, also **doesn't make sense add it in the wishlist\n\n\nWhen the book become available, the system should notify people that are with this book in the wishlist\n\n\nWhen the book is rented by someone that have the book in the wishlist, it should be removed after delivered back\n\n\n\n\nThe application domain is very simple and we're going to build step by step\nthis small logic case to show how granite can be useful and abstract a few\nsteps of your application.\n\n\nNew project setup\n\n\nWe're testing here with Rails version x. The following example can be found\nhere: https://github.com/toptal/example_granite_application\n\n\nGenerating new project\n\n\nThis tutorial is using Rails version \n5.1.4\n and the first step is install it:\n\n\ngem install rails -v\n=\n5\n.1.4\n\n\n\n\n\nNow, with the proper Rails version, let's start a new project:\n\n\nrails new library\n\ncd\n library\n\n\n\n\n\nLet's start setting up the database for development:\n\n\nrails db:setup\n\n\n\n\n\nSetup devise\n\n\nLet's add devise to control users access and have a simple control under logged\nusers. Adding it to \nGemfile\n.\n\n\ngem\n \ndevise\n\n\n\n\n\n\nRun \nbundle install\n and then generate the default devise resources.\n\n\nrails generate devise:install\n\n\n\n\n\nAnd then, let's create a simple devise model to interact with:\n\n\nrails generate devise user\n\n\n\n\n\n\n\nInfo\n\n\nIf you get in any trouble in this section, please check the updated\ndocumentation on the official \nwebsite\n.\n\n\n\n\nSetup granite\n\n\nAdd \ngranite\n to your Gemfile:\n\n\ngem\n \ngranite\n\n\n\n\n\n\nAnd \nbundle install\n again.\n\n\nAdd \nrequire 'granite/rspec'\n to your \nrails_helper.rb\n. Check more details on\nthe \ntesting\n section.\n\n\n\n\nWarning\n\n\nIf you get in any trouble in this section, please\n\nreport an issue\n.\n\n\n\n\nBook::Create\n\n\nIt's time to create our first model and have some initial domain on it.\n\n\nLet's use a scaffold to have a starting point with the \nBook\n model:\n\n\nrails g scaffold book title:string\n\n\n\n\n\nNow, we can start working in the first business action.\n\n\nLet's generate the boilerplate business action class with Rails granite generator:\n\n\nrails\n \ng\n \ngranite\n \nbook\n/\ncreate\n\n\n\n\n\n\nThe following classes was generated:\n\n\n# apq/actions/ba/book/create.rb\n\n\nclass\n \nBA\n::\nBook\n::\nCreate\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n  \nallow_if\n \n{\n \nfalse\n \n}\n\n\n  \nprecondition\n \ndo\n\n  \nend\n\n\n  \nprivate\n\n\n  \ndef\n \nexecute_perform!\n(\n*\n)\n\n    \nsubject\n.\nsave!\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAnd also a default business action was added with the shared subject:\n\n\nclass BA::Book::BusinessAction \n BaseAction\n  subject :book\nend\n\n\n\n\n\nPolicies\n\n\nThe generated code says \nallow_if { false }\n and we need to restrict it to\nlogged users. Let's replace this line to restrict the action only for logged users:\n\n\n# apq/actions/ba/book/create.rb\n\n\nclass\n \nBA\n::\nBook\n::\nCreate\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n  \nallow_if\n \n{\n \nperformer\n.\nis_a?\n(\nUser\n)\n \n}\n\n  \n# ...\n\n\nend\n\n\n\n\n\n\nAnd let's start testing it:\n\n\nrequire\n \nrails_helper\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nCreate\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n \n}\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\nnew\n \n}\n\n\n  \ndescribe\n \npolicies\n \ndo\n\n    \nit\n \n{\n \nis_expected\n.\nto\n \nbe_allowed\n \n}\n\n\n    \ncontext\n \nwhen user is not authorized\n \ndo\n\n      \nlet\n(\n:performer\n)\n \n{\n \ndouble\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nnot_to\n \nbe_allowed\n \n}\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAttributes\n\n\nWe also need to be specific of what attributes this action can touch and then\nwe need to define attributes for it:\n\n\n# apq/actions/ba/book/create.rb\n\n\nclass\n \nBA\n::\nBook\n::\nCreate\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n  \n# ...\n\n  \nrepresents\n \n:title\n,\n \nof\n:\n \n:subject\n\n  \n# ...\n\n\nend\n\n\n\n\n\n\nWe can define some validations to not allow try to save without specify a\ntitle:\n\n\n# apq/actions/ba/book/create.rb\n\n\nclass\n \nBA\n::\nBook\n::\nCreate\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n  \n# ...\n\n  \nvalidates\n \n:title\n,\n \npresence\n:\n \ntrue\n\n  \n# ...\n\n\nend\n\n\n\n\n\n\nAnd now we can properly test it:\n\n\nrequire\n \nrails_helper\n\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nCreate\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nattributes\n)\n \n}\n\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\nnew\n \n}\n\n  \nlet\n(\n:attributes\n)\n \n{\n \n{\n \ntitle\n \n=\n \nRuby Pickaxe\n}\n \n}\n\n\n  \ndescribe\n \npolicies\n \ndo\n\n    \nit\n \n{\n \nis_expected\n.\nto\n \nbe_allowed\n \n}\n\n\n    \ncontext\n \nwhen user is not authorized\n \ndo\n\n      \nlet\n(\n:performer\n)\n \n{\n \ndouble\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nnot_to\n \nbe_allowed\n \n}\n\n    \nend\n\n  \nend\n\n\n  \ndescribe\n \nvalidations\n \ndo\n\n    \nit\n \n{\n \nis_expected\n.\nto\n \nbe_valid\n \n}\n\n\n    \ncontext\n \nwhen preconditions fail\n \ndo\n\n      \nlet\n(\n:attributes\n)\n \n{\n \n{\n \n}\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nnot_to\n \nbe_valid\n \n}\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nPerform\n\n\nFor now, the perform is a simple call to \nbook.save!\n because granite already\nassign the attributes.\n\n\nThen we need to test if it's generating the right record:\n\n\nrequire\n \nrails_helper\n\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nCreate\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nattributes\n)\n \n}\n\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\nnew\n \n}\n\n  \nlet\n(\n:attributes\n)\n \n{\n \n{\n \ntitle\n \n=\n \nRuby Pickaxe\n}\n \n}\n\n\n  \n# describe \npolicies\n ...\n\n  \n# describe \nvalidations\n ...\n\n\n  \ndescribe\n \n#perform!\n \ndo\n\n    \nspecify\n \ndo\n\n      \nexpect\n \n{\n \naction\n.\nperform!\n \n}\n.\nto\n \nchange\n \n{\n \nBook\n.\ncount\n \n}\n.\nby\n(\n1\n)\n\n      \nexpect\n(\naction\n.\nsubject\n.\nattributes\n.\nexcept\n(\nid\n,\n \ncreated_at\n,\n \nupdated_at\n))\n.\nto\n \neq\n(\nattributes\n)\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nThe last step is replace the current book creation in the controller to call\nthe BA instead.\n\n\nFirst thing is rescue from Granite::NotAllowed when some action is not allowed\nto be executed.\n\n\nclass\n \nBooksController\n \n \nApplicationController\n\n  \nrescue_from\n \nGranite\n::\nAction\n::\nNotAllowedError\n \ndo\n \n|\nexception\n|\n\n    \nredirect_to\n \nbooks_path\n,\n \nalert\n:\n \nYou\\\nre not allowed to execute this action.\n\n  \nend\n\n  \n# ...\n\n\nend\n\n\n\n\n\n\nIt will generically manage exceptions case some unauthorized user try to\nforce performing an action without having access.\n\n\nThe next step is wrap the method \n#create\n with the proper business action\ncall.\n\n\nclass\n \nBooksController\n \n \nApplicationController\n\n\n  \n# ...\n\n\n  \n# POST /books\n\n  \ndef\n \ncreate\n\n    \nbook_action\n \n=\n \nBA\n::\nBook\n::\nCreate\n.\nas\n(\ncurrent_user\n)\n.\nnew\n(\nbook_params\n)\n\n      \nif\n \nbook_action\n.\nperform\n\n        \nredirect_to\n \nbook_action\n.\nsubject\n,\n \nnotice\n:\n \nBook was successfully created.\n\n      \nelse\n\n        \n@book\n \n=\n \nbook_action\n.\nsubject\n\n        \nrender\n \n:new\n\n      \nend\n\n    \nend\n\n  \nend\n\n\n  \n# ...\n\n\nend\n\n\n\n\n\n\nBook::Rent\n\n\nThe Rental system description says:\n\n\n\n\nAll available books can be \nrented\n\n\nLogged users can rent a book\n\n\nA book is not \navailable\n when it's rented to someone\n\n\nA book is \navailable\n after it's delivered back\n\n\n\n\nSo, what we're going to do is:\n\n\n\n\nGenerate migration to create the rental table referencing the book and the user\n\n\nAdd an \navailable\n boolean column in the books table\n\n\nCreate a business action \nBook::Rent\n and test the conditions above\n\n\n\n\nLet's create \nRent\n model first:\n\n\nrails g model rent book:references user:references delivered_back_at:timestamp\n\n\n\n\n\nand add available column in the books table:\n\n\nrails g migration add_availability_to_books available:boolean\n\n\n\n\n\nNow it's time to generate the next granite action:\n\n\nrails g granite book/rent\n\n\n\n\n\nPreconditions\n\n\nLet's write specs for the preconditions first:\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nRent\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nbook\n)\n \n}\n\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\nnew\n \n}\n\n\n  \nlet\n(\n:book\n)\n \n{\n \nBook\n.\nnew\n(\ntitle\n:\n \nFirst book\n,\n \navailable\n:\n \navailable\n)\n \n}\n\n\n  \ndescribe\n \npreconditions\n \ndo\n\n    \ncontext\n \nwith available book\n \ndo\n\n      \nlet\n(\n:available\n)\n \n{\n \ntrue\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nto\n \nbe_satisfy_preconditions\n \n}\n\n    \nend\n\n\n    \ncontext\n \nwith unavailable book\n \ndo\n\n      \nlet\n(\n:available\n)\n \n{\n \nfalse\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nto\n \nbe_invalid\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nnot_to\n \nsatisfy_preconditions\n \n}\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nPreconditions\n are related to the book in the context.\nAnd the action will decline the context to not be executed if it does not satisfy the preconditions.\n\n\nLet's implement the \nprecondition\n and \nperform\n code:\n\n\nclass\n \nBA\n::\nBook\n::\nRent\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n  \nprecondition\n \n{\n \nbook\n.\navailable?\n \n}\n\n\n  \nprivate\n\n\n  \ndef\n \nexecute_perform!\n(\n*\n)\n\n    \nRental\n.\ncreate!\n(\nbook\n:\n \nsubject\n,\n \nuser\n:\n \nperformer\n)\n\n    \nsubject\n.\navailable\n \n=\n \nfalse\n\n    \nsubject\n.\nsave!\n\n  \nend\n\n\nend\n\n\n\n\n\n\nNow, let's cover the perform with another spec:\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nRent\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nbook\n)\n \n}\n\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\nnew\n \n}\n\n\n  \nlet\n(\n:book\n)\n \n{\n \nBook\n.\nnew\n(\ntitle\n:\n \nFirst book\n,\n \navailable\n:\n \navailable\n)\n \n}\n\n\n  \n# describe \npreconditions\n ...\n\n\n  \ndescribe\n \n#perform!\n \ndo\n\n    \nspecify\n \ndo\n\n      \nexpect\n \n{\n \naction\n.\nperform!\n \n}\n\n        \n.\nto\n \nchange\n(\nbook\n,\n \n:available\n)\n.\nfrom\n(\ntrue\n)\n.\nto\n(\nfalse\n)\n\n        \n.\nand\n \nchange\n(\nRent\n,\n \n:count\n)\n.\nby\n(\n1\n)\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nBook::DeliverBack\n\n\nTo deliver back a book, it need to be rented by the person that is logged in.\n\n\nThen we need to have a precondition to verify if the current book is being\nrented by this person:\n\n\nclass\n \nBA\n::\nBook\n::\nDeliverBack\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n  \nprecondition\n \ndo\n\n    \nrental_conditions\n \n=\n \n{\n \nbook\n:\n \nsubject\n,\n \nuser\n:\n \nperformer\n,\n \ndelivered_back_at\n:\n \nnil\n \n}\n\n    \nRental\n.\nwhere\n(\nrental_conditions\n)\n.\nexists?\n\n  \nend\n\n\nend\n\n\n\n\n\n\nThe logic of the deliver back, we just need to pick the current rental and\nassign the \ndelivered_back_at\n date. Also, make the book available again.\n\n\nLet's start by testing the preconditions and guarantee that only the user that\nrent the book can deliver it back.\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nDeliverBack\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nbook\n)\n \n}\n\n\n  \nlet\n(\n:book\n)\n \n{\n \nBook\n.\ncreate!\n \ntitle\n:\n \nLearn to fly\n,\n \navailable\n:\n \ntrue\n \n}\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\ncreate!\n \n}\n\n\n  \ndescribe\n \npreconditions\n \ndo\n\n    \ncontext\n \nwhen the user rented the book\n \ndo\n\n      \nbefore\n \n{\n \nBA\n::\nBook\n::\nRent\n.\nas\n(\nperformer\n)\n.\nnew\n(\nbook\n)\n.\nperform!\n \n}\n\n      \nit\n \n{\n \nis_expected\n.\nto\n \nbe_satisfy_preconditions\n \n}\n\n    \nend\n\n\n    \ncontext\n \nwhen preconditions fail\n \ndo\n\n      \nit\n \n{\n \nis_expected\n.\nnot_to\n \nbe_satisfy_preconditions\n \n}\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAnd implementing the preconditions:\n\n\nclass\n \nBA\n::\nBook\n::\nDeliverBack\n \n \nBA\n::\nBook\n::\nBusinessAction\n\n\n  \nsubject\n \n:book\n\n  \nallow_if\n \n{\n \nperformer\n.\nis_a?\n(\nUser\n)\n \n}\n\n\n  \nprecondition\n \ndo\n\n    \ndecline_with\n(\n:not_renting\n)\n \nunless\n \nperformer\n.\nrenting?\n(\nbook\n)\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAnd the \nUser\n now have a few scopes and the \n#renting?\n method:\n\n\nclass\n \nUser\n \n \nApplicationRecord\n\n  \ndevise\n \n:database_authenticatable\n,\n \n:registerable\n\n  \nhas_many\n \n:rentals\n\n  \nhas_many\n \n:books\n,\n \nthrough\n:\n \n:rents\n\n\n  \ndef\n \nrenting?\n(\nbook\n)\n\n    \nrentals\n.\ncurrent\n.\nwhere\n(\nbook_id\n:\n \nbook\n.\nid\n)\n.\nexists?\n\n  \nend\n\n\nend\n\n\n\n\n\n\nNow implementing the spec that covers the logic of deliver back, is expected to\nmake the book available and mark the rental with the delivered date.\n\n\nRSpec\n.\ndescribe\n \nBA\n::\nBook\n::\nDeliverBack\n \ndo\n\n  \nsubject\n(\n:action\n)\n \n{\n \ndescribed_class\n.\nas\n(\nperformer\n)\n.\nnew\n(\nbook\n)\n \n}\n\n\n  \nlet\n(\n:book\n)\n \n{\n \nBook\n.\ncreate!\n \ntitle\n:\n \nLearn to fly\n,\n \navailable\n:\n \ntrue\n \n}\n\n  \nlet\n(\n:performer\n)\n \n{\n \nUser\n.\ncreate!\n \n}\n\n\n  \n# describe \npreconditions\n ...\n\n\n  \ndescribe\n \n#perform!\n \ndo\n\n    \nlet!\n(\n:rental\n)\n \n{\n \nBA\n::\nBook\n::\nRent\n.\nas\n(\nperformer\n)\n.\nnew\n(\nbook\n)\n.\nperform!\n \n}\n\n\n    \nspecify\n \ndo\n\n      \nexpect\n \n{\n \naction\n.\nperform!\n \n}\n\n        \n.\nto\n \nchange\n \n{\n \nbook\n.\nreload\n.\navailable\n \n}\n.\nfrom\n(\nfalse\n)\n.\nto\n(\ntrue\n)\n\n        \n.\nand\n \nchange\n \n{\n \nrental\n.\nreload\n.\ndelivered_back_at\n \n}\n.\nfrom\n(\nnil\n)\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nI18n\n\n\nA last step to make it user friendly is add a key to return a personalized\nmessage when the business action calls \ndecline_with(:unavailable)\n.\n\n\nIt's time to create \nconfig/locales/granite.en.yml\n file:\n\n\nen:\n  granite_action:\n    errors:\n      models:\n        ba/book/rent:\n          attributes:\n            base:\n              unavailable: \nThe book is unavailable.\n\n\n\n\n\n\nGreat! Now it's time to change our views to allow people to interact with the\nactions we created.\n\n\nFirst, we need to add controller methods to call the \nRent\n and \nDeliverBack\n\nbusiness actions and create routes for it.\n\n\nclass\n \nBooksController\n \n \nApplicationController\n\n\n  \n# a few other scaffold methods here...\n\n\n  \n# POST /books/1/rent\n\n  \ndef\n \nrent\n\n    \n@book\n \n=\n \nBook\n.\nfind\n(\nparams\n[\n:book_id\n]\n)\n\n    \nbook_action\n \n=\n \nBA\n::\nBook\n::\nRent\n.\nas\n(\ncurrent_user\n)\n.\nnew\n(\n@book\n)\n\n    \nif\n \nbook_action\n.\nperform\n\n      \nredirect_to\n \nbooks_url\n,\n \nnotice\n:\n \nBook was successfully rented.\n\n    \nelse\n\n      \nredirect_to\n \nbooks_url\n,\n \nalert\n:\n  \nbook_action\n.\nerrors\n.\nfull_messages\n\n    \nend\n\n  \nend\n\n\n  \n# POST /books/1/deliver_back\n\n  \ndef\n \ndeliver_back\n\n    \n@book\n \n=\n \nBook\n.\nfind\n(\nparams\n[\n:book_id\n]\n)\n\n    \nbook_action\n \n=\n \nBA\n::\nBook\n::\nDeliverBack\n.\nas\n(\ncurrent_user\n)\n.\nnew\n(\n@book\n)\n\n      \nif\n \nbook_action\n.\nperform\n\n        \nredirect_to\n \nbooks_url\n,\n \nnotice\n:\n \nThanks for delivering it back.\n\n      \nelse\n\n        \nredirect_to\n \nbooks_url\n,\n \nalert\n:\n  \nbook_action\n.\nerrors\n.\nfull_messages\n\n      \nend\n\n    \nend\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAnd add routes for \nrent\n and \ndeliver_back\n in \nconfig/routes.rb\n:\n\n\n  \nresources\n \n:books\n \ndo\n\n    \npost\n \n:rent\n\n    \npost\n \n:deliver_back\n\n  \nend\n\n\n\n\n\n\nNow, it's time to change the current view to add such actions:\n\n\n  \ntbody\n\n\n    \n%\n \n@books\n.\neach\n \ndo\n \n|\nbook\n|\n \n%\n\n\n      \ntr\n\n\n        \ntd\n%=\n \nbook\n.\ntitle\n \n%\n/td\n\n\n        \n%\n \nif\n \nbook\n.\navailable?\n \n%\n\n\n          \ntd\n%=\n \nlink_to\n \nRent\n,\n \nrent_book_path\n(\nbook\n),\n \nmethod\n:\n \n:post\n \n%\n/td\n\n\n        \n%\n \nelse\n \n%\n\n\n          \ntd\n(Rented)\n/td\n\n\n        \n%\n \nend\n \n%\n\n\n        \n%\n \nif\n \ncurrent_user\n \n \ncurrent_user\n.\nrenting?\n(\nbook\n)\n \n%\n\n\n           \ntd\n%=\n \nlink_to\n \nDeliver back\n,\n \ndeliver_back_book_path\n(\nbook\n),\n \nmethod\n:\n \n:post\n \n%\n/td\n\n\n        \n%\n \nend\n \n%\n\n\n        \ntd\n%=\n \nlink_to\n \nShow\n,\n \nbook\n \n%\n/td\n\n\n        \ntd\n%=\n \nlink_to\n \nEdit\n,\n \nedit_book_path\n(\nbook\n)\n \n%\n/td\n\n\n        \ntd\n%=\n \nlink_to\n \nDestroy\n,\n \nbook\n,\n \nmethod\n:\n \n:delete\n,\n \ndata\n:\n \n{\n \nconfirm\n:\n \nDo you really want to destroy this book?\n \n}\n \n%\n/td\n\n\n      \n/tr\n\n\n    \n%\n \nend\n \n%\n\n\n  \n/tbody\n\n\n\n\n\n\nNow is a good opportunity to introduce \nprojectors\n.\n\n\nLook that we have a few boilerplate code in the controller that make us repeat a\nfew different logics that are already declared in the business action.\n\n\nProjectors can help with that. Avoiding the need of creating repetivive\ncontroller methods and reverify preconditions and policies to decide what\nactions can be executed.\n\n\nSetup view context for Granite projector\n\n\nYou'll need to setup the master controller class. Let's create a file to setup\nit:\n\n\nconfig/initializers/granite.rb\n\n\nGranite\n.\ntap\n \ndo\n \n|\nm\n|\n\n  \nm\n.\nbase_controller\n \n=\n \nApplicationController\n\n\nend\n\n\n\n\n\n\nThe next step is setup granite in the \nApplicationController\n to setup context\nview and allow granite to inherit behavior from it.\n\n\napp/controllers/application_controller\n\n\nclass\n \nApplicationController\n \n \nActionController\n::\nBase\n\n  \nprotect_from_forgery\n \nwith\n:\n \n:exception\n\n  \naround_action\n \n:setup_granite_view_context\n\n  \nbefore_action\n \n{\n \nview_context\n \n}\n\n\n  \nprotected\n\n  \ndef\n \nsetup_granite_view_context\n(\nblock\n)\n\n    \nGranite\n.\nwith_view_context\n(\nview_context\n,\n \nblock\n)\n\n  \nend\n\n\nend\n\n\n\n\n\n\nInline projector\n\n\nThe current \nrent\n and \ndelivered_back\n methods have a very similar structure.\n\n\nAnd the projectors allows to simply declare the HTTP method like \nget\n or\n\npost\n and mount it in a route as an anonymous controller.\n\n\nInside the block, the action is already set with all parameters from the web\nrequest and ready to be executed.\n\n\nAs the current controller actions are executed with POST, let's follow in the same line and\ncreate a simple projector that allows to receive some post data and redirect to the resources list back.\n\n\nThe projector will have a default \nsuccess_redirect\n and \nfailure_redirect\n after perform the action.\nBy default, let's assume that we'll redirect it to the collection and render a\npositive notice or a negative alert about the previous action.\n\n\nclass\n \nInlineProjector\n \n \nGranite\n::\nProjector\n\n\n  \npost\n \n:perform\n,\n \nas\n:\n \n \ndo\n\n    \nif\n \naction\n.\nperform!\n\n      \nredirect_to\n \nprojector\n.\nsuccess_redirect\n,\n \nnotice\n:\n \nt\n(\n.notice\n)\n\n    \nelse\n\n      \nmessages\n \n=\n \nprojector\n.\naction\n.\nerrors\n.\nfull_messages\n.\nto_sentence\n\n      \nredirect_to\n \nprojector\n.\nfailure_redirect\n,\n \nalert\n:\n  \nt\n(\n.error\n,\n \nmessages\n)\n\n    \nend\n\n  \nend\n\n\n  \ndef\n \ncollection_subject\n\n    \naction\n.\nsubject\n.\nclass\n.\nname\n.\ndowncase\n.\npluralize\n\n  \nend\n\n\n  \ndef\n \nsuccess_redirect\n\n    \nh\n.\npublic_send\n(\n#{\ncollection_subject\n}\n_path\n)\n\n  \nend\n\n\n  \ndef\n \nbuild_action\n(\n*\nargs\n)\n\n    \naction_class\n.\nas\n(\nself\n.\nclass\n.\nproxy_performer\n \n||\n \nh\n.\ncurrent_user\n)\n.\nnew\n(\n*\nargs\n)\n\n  \nend\n\n\nend\n\n\n\n\n\n\nWe also need to say who is the performer of the action.\nhe \nbuild_action\n method in the projector is implemented to override the\ncurrent performer in the action with the \ncurrent_role\n.\n\n\n\n\nInfo\n\n\nNote that \nh\n is an alias for \nview_context\n and you can access anything\nfrom the controller through it.\n\n\n\n\nNow, it's time to say that we're going to use the projector inside the \nRent\n action:\n\n\nFile: \napq/actions/ba/book/rent.rb\n\n\nclass BA::Book::Rent \n BaseAction\n  subject :book\n\n\n+  projector :inline\n\n\n  allow_if { performer.is_a?(User) }\n\n  precondition do\n    decline_with(:unavailable) unless book.available?\n  end\n\n  private\n\n  def execute_perform!(*)\n    subject.available = false\n    subject.save!\n    ::Rental.create!(book: subject, user: performer)\n  end\nend\n\n\n\n\n\nAnd also drop the method from the \nBooksController\n:\n\n\nFile: \napp/controllers/books_controller.rb\n\n\n@@ -25,28 +25,6 @@ class BooksController \n ApplicationController\n\n     @book = Book.find(params[:id])\n   end\n\n\n-  # POST /books/1/rent\n\n\n-  def rent\n\n\n-    @book = Book.find(params[:book_id])\n\n\n-    book_action = BA::Book::Rent.as(current_user).new(@book)\n\n\n-    if book_action.perform\n\n\n-      redirect_to books_url, notice: \nBook was successfully rented.\n\n\n-    else\n\n\n-      redirect_to books_url, alert:  book_action.errors.full_messages.to_sentence\n\n\n-    end\n\n\n-  end\n\n\n\n\n\n\nAs a last step we need to change the \nconfig/routes.rb\n to use the \ngranite\n\nkeyword to mount the \naction#projector\n into some route.\n\n\nFile: \nconfig/routes.rb\n\n\nRails.application.routes.draw do\n  root \nbooks#index\n\n\n  devise_for :users\n\n  resources :books do\n\n-   post :rent\n\n\n+   granite \nBA/book/rent#inline\n\n    post :deliver_back\n  end\nend\n\n\n\n\n\n\n\nWarning\n\n\nAs it's a tutorial, your next task is do the same for \ndeliver_back\n.\n\n\n\n\nAdd \nprojector :inline\n to \nBA::Book::DeliverBack\n class.\n\n\nRemove the controller method\n\n\nRefactor the route declaring the \ngranite 'action#projector'\n\n\n\n\n\n\nProjector Helpers\n\n\nYou can define useful methods for helping you rendering your view and improving\nthe experience with your actions. Now, let's create a \nbutton\n function,\nto replace the action links in the current list.\n\n\nFirst, we need to have a method in our projector that can render the button if\nthe action is performable.\n\n\nIt will render nothing if the current user does not have access or it's an\nanonymous session.\n\n\nWe'll render the action name striked if the action is not performable with the\nerror messages in the title, because if people mouse over they can see the\n\"tooltip\" with why it's not possible to execute the action.\n\n\nclass\n \nInlineProjector\n \n \nGranite\n::\nProjector\n\n\n  \n# ...\n\n  \n# The previous methods remains here\n\n  \n# ...\n\n\n  \ndef\n \nbutton\n(\nlink_options\n \n=\n \n{})\n\n    \nreturn\n \nunless\n \naction\n.\nallowed?\n\n    \nif\n \naction\n.\nperformable?\n\n      \nh\n.\nlink_to\n \naction_label\n,\n \nperform_path\n,\n \nmethod\n:\n \n:post\n\n    \nelse\n\n      \nh\n.\ncontent_tag\n(\n:strike\n,\n \naction_label\n,\n \ntitle\n:\n \naction\n.\nerrors\n.\nfull_messages\n.\nto_sentence\n)\n\n    \nend\n\n  \nend\n\n\n  \ndef\n \naction_label\n\n    \naction\n.\nclass\n.\nname\n.\ndemodulize\n.\nunderscore\n.\nhumanize\n\n  \nend\n\n\nend\n\n\n\n\n\n\nAnd now, we can replace the links with the new \nbutton\n function:\n\n\n  \ntbody\n\n\n    \n%\n \n@books\n.\neach\n \ndo\n \n|\nbook\n|\n \n%\n\n\n      \ntr\n\n\n        \ntd\n%=\n \nbook\n.\ntitle\n \n%\n/td\n\n\n        \ntd\n%=\n \nBa\n::\nBook\n::\nRent\n.\nas\n(\ncurrent_user\n)\n.\nnew\n(\nbook\n)\n.\ninline\n.\nbutton\n%\n/td\n\n\n        \ntd\n%=\n \nBa\n::\nBook\n::\nDeliverBack\n.\nas\n(\ncurrent_user\n)\n.\nnew\n(\nbook\n)\n.\ninline\n.\nbutton\n%\n/td\n\n\n        \ntd\n... more links here ...\n/td\n\n\n      \n/tr\n\n\n    \n%\n \nend\n \n%\n\n\n  \n/tbody\n\n\n\n\n\n\nNow it's very clear and the \"Deliver Back\" link will appear only for the user\nthat rented the book.\n\n\nWishlist::Add\n\n\nWishlist::Remove\n\n\nWishlist::NotifyAvailability", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#application-example", 
            "text": "The business we're going to cover is very simple.  We have a simple book library and we need to allow logged users to create new\nbooks and rent it.", 
            "title": "Application example"
        }, 
        {
            "location": "/tutorial/#book-library", 
            "text": "A symple system to track books. Each book has a title.   The books view is public  Only  logged users can edit the books  Logged users can  edit  or  remove  a book", 
            "title": "Book library"
        }, 
        {
            "location": "/tutorial/#the-rental-system", 
            "text": "All available books can be  rented  Logged users can rent a book  A book is not  available  when it's rented to someone  A book is  available  after it's delivered back", 
            "title": "The Rental system"
        }, 
        {
            "location": "/tutorial/#books-wishlist", 
            "text": "The logged user can manage a  wishlist  considering:   When a book is  not available  and the user \" didn't read  it  If the person  already read  the book, also **doesn't make sense add it in the wishlist  When the book become available, the system should notify people that are with this book in the wishlist  When the book is rented by someone that have the book in the wishlist, it should be removed after delivered back   The application domain is very simple and we're going to build step by step\nthis small logic case to show how granite can be useful and abstract a few\nsteps of your application.", 
            "title": "Books wishlist"
        }, 
        {
            "location": "/tutorial/#new-project-setup", 
            "text": "We're testing here with Rails version x. The following example can be found\nhere: https://github.com/toptal/example_granite_application", 
            "title": "New project setup"
        }, 
        {
            "location": "/tutorial/#generating-new-project", 
            "text": "This tutorial is using Rails version  5.1.4  and the first step is install it:  gem install rails -v = 5 .1.4  Now, with the proper Rails version, let's start a new project:  rails new library cd  library  Let's start setting up the database for development:  rails db:setup", 
            "title": "Generating new project"
        }, 
        {
            "location": "/tutorial/#setup-devise", 
            "text": "Let's add devise to control users access and have a simple control under logged\nusers. Adding it to  Gemfile .  gem   devise   Run  bundle install  and then generate the default devise resources.  rails generate devise:install  And then, let's create a simple devise model to interact with:  rails generate devise user   Info  If you get in any trouble in this section, please check the updated\ndocumentation on the official  website .", 
            "title": "Setup devise"
        }, 
        {
            "location": "/tutorial/#setup-granite", 
            "text": "Add  granite  to your Gemfile:  gem   granite   And  bundle install  again.  Add  require 'granite/rspec'  to your  rails_helper.rb . Check more details on\nthe  testing  section.   Warning  If you get in any trouble in this section, please report an issue .", 
            "title": "Setup granite"
        }, 
        {
            "location": "/tutorial/#bookcreate", 
            "text": "It's time to create our first model and have some initial domain on it.  Let's use a scaffold to have a starting point with the  Book  model:  rails g scaffold book title:string  Now, we can start working in the first business action.  Let's generate the boilerplate business action class with Rails granite generator:  rails   g   granite   book / create   The following classes was generated:  # apq/actions/ba/book/create.rb  class   BA :: Book :: Create     BA :: Book :: BusinessAction \n   allow_if   {   false   } \n\n   precondition   do \n   end \n\n   private \n\n   def   execute_perform! ( * ) \n     subject . save! \n   end  end   And also a default business action was added with the shared subject:  class BA::Book::BusinessAction   BaseAction\n  subject :book\nend", 
            "title": "Book::Create"
        }, 
        {
            "location": "/tutorial/#policies", 
            "text": "The generated code says  allow_if { false }  and we need to restrict it to\nlogged users. Let's replace this line to restrict the action only for logged users:  # apq/actions/ba/book/create.rb  class   BA :: Book :: Create     BA :: Book :: BusinessAction \n   allow_if   {   performer . is_a? ( User )   } \n   # ...  end   And let's start testing it:  require   rails_helper  RSpec . describe   BA :: Book :: Create   do \n   subject ( :action )   {   described_class . as ( performer ) . new   } \n   let ( :performer )   {   User . new   } \n\n   describe   policies   do \n     it   {   is_expected . to   be_allowed   } \n\n     context   when user is not authorized   do \n       let ( :performer )   {   double   } \n       it   {   is_expected . not_to   be_allowed   } \n     end \n   end  end", 
            "title": "Policies"
        }, 
        {
            "location": "/tutorial/#attributes", 
            "text": "We also need to be specific of what attributes this action can touch and then\nwe need to define attributes for it:  # apq/actions/ba/book/create.rb  class   BA :: Book :: Create     BA :: Book :: BusinessAction \n   # ... \n   represents   :title ,   of :   :subject \n   # ...  end   We can define some validations to not allow try to save without specify a\ntitle:  # apq/actions/ba/book/create.rb  class   BA :: Book :: Create     BA :: Book :: BusinessAction \n   # ... \n   validates   :title ,   presence :   true \n   # ...  end   And now we can properly test it:  require   rails_helper  RSpec . describe   BA :: Book :: Create   do \n   subject ( :action )   {   described_class . as ( performer ) . new ( attributes )   } \n\n   let ( :performer )   {   User . new   } \n   let ( :attributes )   {   {   title   =   Ruby Pickaxe }   } \n\n   describe   policies   do \n     it   {   is_expected . to   be_allowed   } \n\n     context   when user is not authorized   do \n       let ( :performer )   {   double   } \n       it   {   is_expected . not_to   be_allowed   } \n     end \n   end \n\n   describe   validations   do \n     it   {   is_expected . to   be_valid   } \n\n     context   when preconditions fail   do \n       let ( :attributes )   {   {   }   } \n       it   {   is_expected . not_to   be_valid   } \n     end \n   end  end", 
            "title": "Attributes"
        }, 
        {
            "location": "/tutorial/#perform", 
            "text": "For now, the perform is a simple call to  book.save!  because granite already\nassign the attributes.  Then we need to test if it's generating the right record:  require   rails_helper  RSpec . describe   BA :: Book :: Create   do \n   subject ( :action )   {   described_class . as ( performer ) . new ( attributes )   } \n\n   let ( :performer )   {   User . new   } \n   let ( :attributes )   {   {   title   =   Ruby Pickaxe }   } \n\n   # describe  policies  ... \n   # describe  validations  ... \n\n   describe   #perform!   do \n     specify   do \n       expect   {   action . perform!   } . to   change   {   Book . count   } . by ( 1 ) \n       expect ( action . subject . attributes . except ( id ,   created_at ,   updated_at )) . to   eq ( attributes ) \n     end \n   end  end   The last step is replace the current book creation in the controller to call\nthe BA instead.  First thing is rescue from Granite::NotAllowed when some action is not allowed\nto be executed.  class   BooksController     ApplicationController \n   rescue_from   Granite :: Action :: NotAllowedError   do   | exception | \n     redirect_to   books_path ,   alert :   You\\ re not allowed to execute this action. \n   end \n   # ...  end   It will generically manage exceptions case some unauthorized user try to\nforce performing an action without having access.  The next step is wrap the method  #create  with the proper business action\ncall.  class   BooksController     ApplicationController \n\n   # ... \n\n   # POST /books \n   def   create \n     book_action   =   BA :: Book :: Create . as ( current_user ) . new ( book_params ) \n       if   book_action . perform \n         redirect_to   book_action . subject ,   notice :   Book was successfully created. \n       else \n         @book   =   book_action . subject \n         render   :new \n       end \n     end \n   end \n\n   # ...  end", 
            "title": "Perform"
        }, 
        {
            "location": "/tutorial/#bookrent", 
            "text": "The Rental system description says:   All available books can be  rented  Logged users can rent a book  A book is not  available  when it's rented to someone  A book is  available  after it's delivered back   So, what we're going to do is:   Generate migration to create the rental table referencing the book and the user  Add an  available  boolean column in the books table  Create a business action  Book::Rent  and test the conditions above   Let's create  Rent  model first:  rails g model rent book:references user:references delivered_back_at:timestamp  and add available column in the books table:  rails g migration add_availability_to_books available:boolean  Now it's time to generate the next granite action:  rails g granite book/rent", 
            "title": "Book::Rent"
        }, 
        {
            "location": "/tutorial/#preconditions", 
            "text": "Let's write specs for the preconditions first:  RSpec . describe   BA :: Book :: Rent   do \n   subject ( :action )   {   described_class . as ( performer ) . new ( book )   } \n\n   let ( :performer )   {   User . new   } \n\n   let ( :book )   {   Book . new ( title :   First book ,   available :   available )   } \n\n   describe   preconditions   do \n     context   with available book   do \n       let ( :available )   {   true   } \n       it   {   is_expected . to   be_satisfy_preconditions   } \n     end \n\n     context   with unavailable book   do \n       let ( :available )   {   false   } \n       it   {   is_expected . to   be_invalid   } \n       it   {   is_expected . not_to   satisfy_preconditions   } \n     end \n   end  end   Preconditions  are related to the book in the context.\nAnd the action will decline the context to not be executed if it does not satisfy the preconditions.  Let's implement the  precondition  and  perform  code:  class   BA :: Book :: Rent     BA :: Book :: BusinessAction \n   precondition   {   book . available?   } \n\n   private \n\n   def   execute_perform! ( * ) \n     Rental . create! ( book :   subject ,   user :   performer ) \n     subject . available   =   false \n     subject . save! \n   end  end   Now, let's cover the perform with another spec:  RSpec . describe   BA :: Book :: Rent   do \n   subject ( :action )   {   described_class . as ( performer ) . new ( book )   } \n\n   let ( :performer )   {   User . new   } \n\n   let ( :book )   {   Book . new ( title :   First book ,   available :   available )   } \n\n   # describe  preconditions  ... \n\n   describe   #perform!   do \n     specify   do \n       expect   {   action . perform!   } \n         . to   change ( book ,   :available ) . from ( true ) . to ( false ) \n         . and   change ( Rent ,   :count ) . by ( 1 ) \n     end \n   end  end", 
            "title": "Preconditions"
        }, 
        {
            "location": "/tutorial/#bookdeliverback", 
            "text": "To deliver back a book, it need to be rented by the person that is logged in.  Then we need to have a precondition to verify if the current book is being\nrented by this person:  class   BA :: Book :: DeliverBack     BA :: Book :: BusinessAction \n   precondition   do \n     rental_conditions   =   {   book :   subject ,   user :   performer ,   delivered_back_at :   nil   } \n     Rental . where ( rental_conditions ) . exists? \n   end  end   The logic of the deliver back, we just need to pick the current rental and\nassign the  delivered_back_at  date. Also, make the book available again.  Let's start by testing the preconditions and guarantee that only the user that\nrent the book can deliver it back.  RSpec . describe   BA :: Book :: DeliverBack   do \n   subject ( :action )   {   described_class . as ( performer ) . new ( book )   } \n\n   let ( :book )   {   Book . create!   title :   Learn to fly ,   available :   true   } \n   let ( :performer )   {   User . create!   } \n\n   describe   preconditions   do \n     context   when the user rented the book   do \n       before   {   BA :: Book :: Rent . as ( performer ) . new ( book ) . perform!   } \n       it   {   is_expected . to   be_satisfy_preconditions   } \n     end \n\n     context   when preconditions fail   do \n       it   {   is_expected . not_to   be_satisfy_preconditions   } \n     end \n   end  end   And implementing the preconditions:  class   BA :: Book :: DeliverBack     BA :: Book :: BusinessAction \n\n   subject   :book \n   allow_if   {   performer . is_a? ( User )   } \n\n   precondition   do \n     decline_with ( :not_renting )   unless   performer . renting? ( book ) \n   end  end   And the  User  now have a few scopes and the  #renting?  method:  class   User     ApplicationRecord \n   devise   :database_authenticatable ,   :registerable \n   has_many   :rentals \n   has_many   :books ,   through :   :rents \n\n   def   renting? ( book ) \n     rentals . current . where ( book_id :   book . id ) . exists? \n   end  end   Now implementing the spec that covers the logic of deliver back, is expected to\nmake the book available and mark the rental with the delivered date.  RSpec . describe   BA :: Book :: DeliverBack   do \n   subject ( :action )   {   described_class . as ( performer ) . new ( book )   } \n\n   let ( :book )   {   Book . create!   title :   Learn to fly ,   available :   true   } \n   let ( :performer )   {   User . create!   } \n\n   # describe  preconditions  ... \n\n   describe   #perform!   do \n     let! ( :rental )   {   BA :: Book :: Rent . as ( performer ) . new ( book ) . perform!   } \n\n     specify   do \n       expect   {   action . perform!   } \n         . to   change   {   book . reload . available   } . from ( false ) . to ( true ) \n         . and   change   {   rental . reload . delivered_back_at   } . from ( nil ) \n     end \n   end  end", 
            "title": "Book::DeliverBack"
        }, 
        {
            "location": "/tutorial/#i18n", 
            "text": "A last step to make it user friendly is add a key to return a personalized\nmessage when the business action calls  decline_with(:unavailable) .  It's time to create  config/locales/granite.en.yml  file:  en:\n  granite_action:\n    errors:\n      models:\n        ba/book/rent:\n          attributes:\n            base:\n              unavailable:  The book is unavailable.   Great! Now it's time to change our views to allow people to interact with the\nactions we created.  First, we need to add controller methods to call the  Rent  and  DeliverBack \nbusiness actions and create routes for it.  class   BooksController     ApplicationController \n\n   # a few other scaffold methods here... \n\n   # POST /books/1/rent \n   def   rent \n     @book   =   Book . find ( params [ :book_id ] ) \n     book_action   =   BA :: Book :: Rent . as ( current_user ) . new ( @book ) \n     if   book_action . perform \n       redirect_to   books_url ,   notice :   Book was successfully rented. \n     else \n       redirect_to   books_url ,   alert :    book_action . errors . full_messages \n     end \n   end \n\n   # POST /books/1/deliver_back \n   def   deliver_back \n     @book   =   Book . find ( params [ :book_id ] ) \n     book_action   =   BA :: Book :: DeliverBack . as ( current_user ) . new ( @book ) \n       if   book_action . perform \n         redirect_to   books_url ,   notice :   Thanks for delivering it back. \n       else \n         redirect_to   books_url ,   alert :    book_action . errors . full_messages \n       end \n     end \n   end  end   And add routes for  rent  and  deliver_back  in  config/routes.rb :     resources   :books   do \n     post   :rent \n     post   :deliver_back \n   end   Now, it's time to change the current view to add such actions:     tbody       %   @books . each   do   | book |   %         tr           td %=   book . title   % /td           %   if   book . available?   %             td %=   link_to   Rent ,   rent_book_path ( book ),   method :   :post   % /td           %   else   %             td (Rented) /td           %   end   %           %   if   current_user     current_user . renting? ( book )   %              td %=   link_to   Deliver back ,   deliver_back_book_path ( book ),   method :   :post   % /td           %   end   %           td %=   link_to   Show ,   book   % /td           td %=   link_to   Edit ,   edit_book_path ( book )   % /td           td %=   link_to   Destroy ,   book ,   method :   :delete ,   data :   {   confirm :   Do you really want to destroy this book?   }   % /td         /tr       %   end   %     /tbody   Now is a good opportunity to introduce  projectors .  Look that we have a few boilerplate code in the controller that make us repeat a\nfew different logics that are already declared in the business action.  Projectors can help with that. Avoiding the need of creating repetivive\ncontroller methods and reverify preconditions and policies to decide what\nactions can be executed.", 
            "title": "I18n"
        }, 
        {
            "location": "/tutorial/#setup-view-context-for-granite-projector", 
            "text": "You'll need to setup the master controller class. Let's create a file to setup\nit:  config/initializers/granite.rb  Granite . tap   do   | m | \n   m . base_controller   =   ApplicationController  end   The next step is setup granite in the  ApplicationController  to setup context\nview and allow granite to inherit behavior from it.  app/controllers/application_controller  class   ApplicationController     ActionController :: Base \n   protect_from_forgery   with :   :exception \n   around_action   :setup_granite_view_context \n   before_action   {   view_context   } \n\n   protected \n   def   setup_granite_view_context ( block ) \n     Granite . with_view_context ( view_context ,   block ) \n   end  end", 
            "title": "Setup view context for Granite projector"
        }, 
        {
            "location": "/tutorial/#inline-projector", 
            "text": "The current  rent  and  delivered_back  methods have a very similar structure.  And the projectors allows to simply declare the HTTP method like  get  or post  and mount it in a route as an anonymous controller.  Inside the block, the action is already set with all parameters from the web\nrequest and ready to be executed.  As the current controller actions are executed with POST, let's follow in the same line and\ncreate a simple projector that allows to receive some post data and redirect to the resources list back.  The projector will have a default  success_redirect  and  failure_redirect  after perform the action.\nBy default, let's assume that we'll redirect it to the collection and render a\npositive notice or a negative alert about the previous action.  class   InlineProjector     Granite :: Projector \n\n   post   :perform ,   as :     do \n     if   action . perform! \n       redirect_to   projector . success_redirect ,   notice :   t ( .notice ) \n     else \n       messages   =   projector . action . errors . full_messages . to_sentence \n       redirect_to   projector . failure_redirect ,   alert :    t ( .error ,   messages ) \n     end \n   end \n\n   def   collection_subject \n     action . subject . class . name . downcase . pluralize \n   end \n\n   def   success_redirect \n     h . public_send ( #{ collection_subject } _path ) \n   end \n\n   def   build_action ( * args ) \n     action_class . as ( self . class . proxy_performer   ||   h . current_user ) . new ( * args ) \n   end  end   We also need to say who is the performer of the action.\nhe  build_action  method in the projector is implemented to override the\ncurrent performer in the action with the  current_role .   Info  Note that  h  is an alias for  view_context  and you can access anything\nfrom the controller through it.   Now, it's time to say that we're going to use the projector inside the  Rent  action:  File:  apq/actions/ba/book/rent.rb  class BA::Book::Rent   BaseAction\n  subject :book +  projector :inline \n\n  allow_if { performer.is_a?(User) }\n\n  precondition do\n    decline_with(:unavailable) unless book.available?\n  end\n\n  private\n\n  def execute_perform!(*)\n    subject.available = false\n    subject.save!\n    ::Rental.create!(book: subject, user: performer)\n  end\nend  And also drop the method from the  BooksController :  File:  app/controllers/books_controller.rb  @@ -25,28 +25,6 @@ class BooksController   ApplicationController \n     @book = Book.find(params[:id])\n   end -  # POST /books/1/rent  -  def rent  -    @book = Book.find(params[:book_id])  -    book_action = BA::Book::Rent.as(current_user).new(@book)  -    if book_action.perform  -      redirect_to books_url, notice:  Book was successfully rented.  -    else  -      redirect_to books_url, alert:  book_action.errors.full_messages.to_sentence  -    end  -  end   As a last step we need to change the  config/routes.rb  to use the  granite \nkeyword to mount the  action#projector  into some route.  File:  config/routes.rb  Rails.application.routes.draw do\n  root  books#index \n\n  devise_for :users\n\n  resources :books do -   post :rent  +   granite  BA/book/rent#inline \n    post :deliver_back\n  end\nend   Warning  As it's a tutorial, your next task is do the same for  deliver_back .   Add  projector :inline  to  BA::Book::DeliverBack  class.  Remove the controller method  Refactor the route declaring the  granite 'action#projector'", 
            "title": "Inline projector"
        }, 
        {
            "location": "/tutorial/#projector-helpers", 
            "text": "You can define useful methods for helping you rendering your view and improving\nthe experience with your actions. Now, let's create a  button  function,\nto replace the action links in the current list.  First, we need to have a method in our projector that can render the button if\nthe action is performable.  It will render nothing if the current user does not have access or it's an\nanonymous session.  We'll render the action name striked if the action is not performable with the\nerror messages in the title, because if people mouse over they can see the\n\"tooltip\" with why it's not possible to execute the action.  class   InlineProjector     Granite :: Projector \n\n   # ... \n   # The previous methods remains here \n   # ... \n\n   def   button ( link_options   =   {}) \n     return   unless   action . allowed? \n     if   action . performable? \n       h . link_to   action_label ,   perform_path ,   method :   :post \n     else \n       h . content_tag ( :strike ,   action_label ,   title :   action . errors . full_messages . to_sentence ) \n     end \n   end \n\n   def   action_label \n     action . class . name . demodulize . underscore . humanize \n   end  end   And now, we can replace the links with the new  button  function:     tbody       %   @books . each   do   | book |   %         tr           td %=   book . title   % /td           td %=   Ba :: Book :: Rent . as ( current_user ) . new ( book ) . inline . button % /td           td %=   Ba :: Book :: DeliverBack . as ( current_user ) . new ( book ) . inline . button % /td           td ... more links here ... /td         /tr       %   end   %     /tbody   Now it's very clear and the \"Deliver Back\" link will appear only for the user\nthat rented the book.", 
            "title": "Projector Helpers"
        }, 
        {
            "location": "/tutorial/#wishlistadd", 
            "text": "", 
            "title": "Wishlist::Add"
        }, 
        {
            "location": "/tutorial/#wishlistremove", 
            "text": "", 
            "title": "Wishlist::Remove"
        }, 
        {
            "location": "/tutorial/#wishlistnotifyavailability", 
            "text": "", 
            "title": "Wishlist::NotifyAvailability"
        }
    ]
}